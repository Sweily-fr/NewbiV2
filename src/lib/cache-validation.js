/**
 * Script de validation du syst√®me de cache Apollo Client
 * V√©rifie que toutes les configurations sont correctes
 */

import { apolloClient, getApolloClient } from './apolloClient';
import { CACHE_POLICIES, getOptimizedPolicy } from './cache-utils';

/**
 * Valide la configuration du cache Apollo Client
 */
export const validateCacheConfiguration = () => {
  const results = {
    success: true,
    errors: [],
    warnings: [],
    info: [],
  };

  try {
    // 1. V√©rifier que le client Apollo est correctement configur√©
    if (!apolloClient) {
      results.errors.push('Apollo Client non initialis√©');
      results.success = false;
    } else {
      results.info.push('‚úÖ Apollo Client initialis√©');
    }

    // 2. V√©rifier la configuration du cache
    const cache = apolloClient.cache;
    if (!cache) {
      results.errors.push('Cache Apollo non configur√©');
      results.success = false;
    } else {
      results.info.push('‚úÖ Cache Apollo configur√©');
      
      // V√©rifier les typePolicies
      const typePolicies = cache.policies?.typePolicies;
      if (!typePolicies) {
        results.warnings.push('‚ö†Ô∏è Aucune typePolicy configur√©e');
      } else {
        results.info.push(`‚úÖ TypePolicies configur√©es: ${Object.keys(typePolicies).length} types`);
        
        // V√©rifier les types importants
        const requiredTypes = ['Query', 'Invoice', 'Quote', 'Client', 'Product'];
        requiredTypes.forEach(type => {
          if (typePolicies[type]) {
            results.info.push(`‚úÖ TypePolicy ${type} configur√©e`);
          } else {
            results.warnings.push(`‚ö†Ô∏è TypePolicy ${type} manquante`);
          }
        });
      }
    }

    // 3. V√©rifier les politiques de cache
    Object.entries(CACHE_POLICIES).forEach(([name, policy]) => {
      if (policy.fetchPolicy && policy.nextFetchPolicy !== undefined) {
        results.info.push(`‚úÖ Politique ${name} configur√©e`);
      } else {
        results.errors.push(`‚ùå Politique ${name} mal configur√©e`);
        results.success = false;
      }
    });

    // 4. Tester les politiques optimis√©es
    const testCases = [
      { dataType: 'organization', context: 'default' },
      { dataType: 'lists', context: 'table' },
      { dataType: 'forms', context: 'form' },
      { dataType: 'stats', context: 'dashboard' },
    ];

    testCases.forEach(({ dataType, context }) => {
      try {
        const policy = getOptimizedPolicy(dataType, context);
        if (policy.fetchPolicy) {
          results.info.push(`‚úÖ Politique optimis√©e ${dataType}/${context}: ${policy.fetchPolicy}`);
        } else {
          results.warnings.push(`‚ö†Ô∏è Politique optimis√©e ${dataType}/${context} incompl√®te`);
        }
      } catch (error) {
        results.errors.push(`‚ùå Erreur politique ${dataType}/${context}: ${error.message}`);
        results.success = false;
      }
    });

    // 5. V√©rifier les options par d√©faut
    const defaultOptions = apolloClient.defaultOptions;
    if (defaultOptions) {
      results.info.push('‚úÖ Options par d√©faut configur√©es');
      
      if (defaultOptions.watchQuery?.fetchPolicy) {
        results.info.push(`‚úÖ FetchPolicy par d√©faut: ${defaultOptions.watchQuery.fetchPolicy}`);
      }
      
      if (defaultOptions.mutate?.errorPolicy) {
        results.info.push(`‚úÖ ErrorPolicy mutations: ${defaultOptions.mutate.errorPolicy}`);
      }
    } else {
      results.warnings.push('‚ö†Ô∏è Aucune option par d√©faut configur√©e');
    }

    // 6. V√©rifier la persistance du cache (c√¥t√© client uniquement)
    if (typeof window !== 'undefined') {
      try {
        const hasLocalStorage = !!window.localStorage;
        if (hasLocalStorage) {
          results.info.push('‚úÖ LocalStorage disponible pour persistance');
          
          // V√©rifier si le cache persistant existe
          const persistedCache = localStorage.getItem('newbi-apollo-cache');
          if (persistedCache) {
            results.info.push('‚úÖ Cache persistant d√©tect√©');
            try {
              const parsed = JSON.parse(persistedCache);
              const size = JSON.stringify(parsed).length;
              results.info.push(`‚úÖ Taille cache persistant: ${Math.round(size / 1024)} KB`);
            } catch {
              results.warnings.push('‚ö†Ô∏è Cache persistant corrompu');
            }
          } else {
            results.info.push('‚ÑπÔ∏è Aucun cache persistant (normal au premier d√©marrage)');
          }
        } else {
          results.warnings.push('‚ö†Ô∏è LocalStorage non disponible');
        }
      } catch (error) {
        results.warnings.push(`‚ö†Ô∏è Erreur v√©rification persistance: ${error.message}`);
      }
    } else {
      results.info.push('‚ÑπÔ∏è Validation c√¥t√© serveur (persistance non applicable)');
    }

  } catch (error) {
    results.errors.push(`‚ùå Erreur g√©n√©rale: ${error.message}`);
    results.success = false;
  }

  return results;
};

/**
 * Teste les performances du cache avec des donn√©es simul√©es
 */
export const testCachePerformance = async () => {
  const results = {
    success: true,
    errors: [],
    timings: {},
  };

  try {
    // Test 1: √âcriture dans le cache
    const startWrite = performance.now();
    
    const testData = {
      __typename: 'TestEntity',
      id: 'test-1',
      name: 'Test Cache Performance',
      data: new Array(1000).fill('test').join(''),
    };

    apolloClient.cache.writeQuery({
      query: {
        kind: 'Document',
        definitions: [{
          kind: 'OperationDefinition',
          operation: 'query',
          name: { kind: 'Name', value: 'TestQuery' },
          selectionSet: {
            kind: 'SelectionSet',
            selections: [{
              kind: 'Field',
              name: { kind: 'Name', value: 'testEntity' },
              selectionSet: {
                kind: 'SelectionSet',
                selections: [
                  { kind: 'Field', name: { kind: 'Name', value: 'id' } },
                  { kind: 'Field', name: { kind: 'Name', value: 'name' } },
                  { kind: 'Field', name: { kind: 'Name', value: 'data' } },
                ]
              }
            }]
          }
        }]
      },
      data: { testEntity: testData },
    });

    const writeTime = performance.now() - startWrite;
    results.timings.write = writeTime;

    // Test 2: Lecture depuis le cache
    const startRead = performance.now();
    
    const cachedData = apolloClient.cache.readQuery({
      query: {
        kind: 'Document',
        definitions: [{
          kind: 'OperationDefinition',
          operation: 'query',
          name: { kind: 'Name', value: 'TestQuery' },
          selectionSet: {
            kind: 'SelectionSet',
            selections: [{
              kind: 'Field',
              name: { kind: 'Name', value: 'testEntity' },
              selectionSet: {
                kind: 'SelectionSet',
                selections: [
                  { kind: 'Field', name: { kind: 'Name', value: 'id' } },
                  { kind: 'Field', name: { kind: 'Name', value: 'name' } },
                  { kind: 'Field', name: { kind: 'Name', value: 'data' } },
                ]
              }
            }]
          }
        }]
      },
    });

    const readTime = performance.now() - startRead;
    results.timings.read = readTime;

    if (!cachedData || cachedData.testEntity.id !== 'test-1') {
      results.errors.push('‚ùå Donn√©es non trouv√©es dans le cache');
      results.success = false;
    }

    // Test 3: Taille du cache
    const startSize = performance.now();
    const cacheData = apolloClient.cache.extract();
    const cacheSize = JSON.stringify(cacheData).length;
    const sizeTime = performance.now() - startSize;
    
    results.timings.size = sizeTime;
    results.timings.cacheSize = cacheSize;

    // Nettoyer les donn√©es de test
    apolloClient.cache.evict({ fieldName: 'testEntity' });
    apolloClient.cache.gc();

  } catch (error) {
    results.errors.push(`‚ùå Erreur test performance: ${error.message}`);
    results.success = false;
  }

  return results;
};

/**
 * Affiche un rapport de validation complet
 */
export const generateValidationReport = async () => {
  console.log('üîç === VALIDATION DU SYST√àME DE CACHE APOLLO CLIENT ===\n');

  // 1. Validation de la configuration
  console.log('üìã Configuration:');
  const configResults = validateCacheConfiguration();
  
  configResults.info.forEach(info => console.log(`  ${info}`));
  configResults.warnings.forEach(warning => console.log(`  ${warning}`));
  configResults.errors.forEach(error => console.log(`  ${error}`));
  
  console.log(`\nüìä R√©sultat configuration: ${configResults.success ? '‚úÖ SUCC√àS' : '‚ùå √âCHEC'}\n`);

  // 2. Test de performance
  console.log('‚ö° Performance:');
  const perfResults = await testCachePerformance();
  
  if (perfResults.success) {
    console.log(`  ‚úÖ √âcriture cache: ${perfResults.timings.write.toFixed(2)}ms`);
    console.log(`  ‚úÖ Lecture cache: ${perfResults.timings.read.toFixed(2)}ms`);
    console.log(`  ‚úÖ Extraction cache: ${perfResults.timings.size.toFixed(2)}ms`);
    console.log(`  ‚úÖ Taille cache: ${Math.round(perfResults.timings.cacheSize / 1024)}KB`);
  } else {
    perfResults.errors.forEach(error => console.log(`  ${error}`));
  }
  
  console.log(`\nüìä R√©sultat performance: ${perfResults.success ? '‚úÖ SUCC√àS' : '‚ùå √âCHEC'}\n`);

  // 3. Recommandations
  console.log('üí° Recommandations:');
  
  if (perfResults.timings?.write > 10) {
    console.log('  ‚ö†Ô∏è √âcriture cache lente (>10ms) - R√©duire la taille des donn√©es');
  }
  
  if (perfResults.timings?.read > 5) {
    console.log('  ‚ö†Ô∏è Lecture cache lente (>5ms) - Optimiser les requ√™tes');
  }
  
  if (perfResults.timings?.cacheSize > 1024 * 1024) {
    console.log('  ‚ö†Ô∏è Cache volumineux (>1MB) - Consid√©rer le nettoyage automatique');
  }
  
  if (configResults.warnings.length === 0 && perfResults.success) {
    console.log('  üéâ Configuration optimale d√©tect√©e !');
  }

  console.log('\nüèÅ === FIN DE LA VALIDATION ===');
  
  return {
    configuration: configResults,
    performance: perfResults,
    overall: configResults.success && perfResults.success,
  };
};

// Export pour utilisation dans d'autres fichiers
export default {
  validateCacheConfiguration,
  testCachePerformance,
  generateValidationReport,
};
