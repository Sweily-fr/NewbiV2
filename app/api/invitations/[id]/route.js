import { auth } from "@/src/lib/auth";
import { headers } from "next/headers";
import { seatSyncService } from "@/src/services/seatSyncService";
import { emailTemplates } from "@/src/lib/email-templates";
import { sendEmail } from "@/src/lib/auth-utils";

export async function GET(request, { params }) {
  try {
    const { id } = await params;

    // Acc√®s direct √† MongoDB pour r√©cup√©rer l'invitation
    const { mongoDb } = await import("@/src/lib/mongodb");
    const { ObjectId } = await import("mongodb");

    // R√©cup√©rer l'invitation directement depuis MongoDB
    const invitation = await mongoDb
      .collection("invitation")
      .findOne({ _id: new ObjectId(id) });

    if (!invitation) {
      return Response.json(
        { error: "Invitation non trouv√©e" },
        { status: 404 }
      );
    }

    // Enrichir avec les donn√©es d'organisation
    let organizationName = "Organisation inconnue";
    if (invitation.organizationId) {
      try {
        const organization = await mongoDb
          .collection("organization")
          .findOne({ _id: invitation.organizationId });

        organizationName = organization?.name || organizationName;
      } catch (orgError) {
        console.warn("‚ö†Ô∏è Erreur r√©cup√©ration organisation:", orgError);
      }
    }

    const enrichedInvitation = {
      id: invitation._id.toString(),
      email: invitation.email,
      role: invitation.role,
      status: invitation.status,
      expiresAt: invitation.expiresAt,
      organizationId: invitation.organizationId?.toString(),
      organizationName,
      inviterId: invitation.inviterId?.toString(),
    };

    return Response.json(enrichedInvitation);
  } catch (error) {
    console.error("‚ùå Erreur lors de la r√©cup√©ration de l'invitation:", error);
    return Response.json(
      { error: "Erreur serveur", details: error.message },
      { status: 500 }
    );
  }
}

export async function POST(request, { params }) {
  try {
    console.log('üîµ POST /api/invitations/[id] - D√©but');
    
    const { id } = await params;
    const { action } = await request.json();
    
    console.log(`üìã Invitation ID: ${id}, Action: ${action}`);

    // R√©cup√©rer la session utilisateur
    const session = await auth.api.getSession({
      headers: await headers(),
    });
    
    console.log(`üë§ Session utilisateur:`, session?.user?.email || 'Non connect√©');
    
    if (!session) {
      console.log('‚ùå Non authentifi√©');
      return Response.json({ error: "Non authentifi√©" }, { status: 401 });
    }

    if (action === "accept") {
      console.log('‚úÖ Action: Accepter l\'invitation');
      
      // V√©rifier que l'utilisateur est bien le destinataire de l'invitation
      const { mongoDb } = await import("@/src/lib/mongodb");
      const { ObjectId } = await import("mongodb");
      
      const invitation = await mongoDb
        .collection("invitation")
        .findOne({ _id: new ObjectId(id) });
      
      if (!invitation) {
        console.log('‚ùå Invitation non trouv√©e');
        return Response.json(
          { error: "Invitation non trouv√©e" },
          { status: 404 }
        );
      }
      
      console.log(`üìß Email invitation: ${invitation.email}`);
      console.log(`üìß Email utilisateur: ${session.user.email}`);
      
      if (invitation.email.toLowerCase() !== session.user.email.toLowerCase()) {
        console.log('‚ùå L\'utilisateur n\'est pas le destinataire de cette invitation');
        return Response.json(
          { 
            error: "Vous n'√™tes pas le destinataire de cette invitation",
            details: `Cette invitation a √©t√© envoy√©e √† ${invitation.email}, mais vous √™tes connect√© avec ${session.user.email}`
          },
          { status: 403 }
        );
      }
      
      // √âTAPE 1: Accepter l'invitation (rejoint l'organisation de l'owner)
      console.log('üîÑ √âTAPE 1: Appel Better Auth acceptInvitation...');
      const result = await auth.api.acceptInvitation({
        headers: await headers(),
        body: { invitationId: id },
      });

      console.log('üìä R√©sultat acceptInvitation:', result);

      // Better Auth retourne { invitation: {...}, member: {...} }
      const organizationId = result?.invitation?.organizationId || result?.organizationId;
      
      if (!result || !organizationId) {
        console.log('‚ùå √âchec acceptInvitation: pas d\'organizationId');
        return Response.json(
          { error: "√âchec de l'acceptation de l'invitation" },
          { status: 500 }
        );
      }

      console.log(`‚úÖ √âTAPE 1 OK: Membre ajout√© √† l'organisation ${organizationId}`);

      // √âTAPE 3: D√©finir l'organisation comme active IMM√âDIATEMENT
      try {
        console.log('üîÑ √âTAPE 3: Appel Better Auth setActiveOrganization...');
        await auth.api.setActiveOrganization({
          headers: await headers(),
          body: { organizationId },
        });
        console.log(
          `‚úÖ √âTAPE 3 OK: Organisation ${organizationId} d√©finie comme active`
        );
      } catch (orgError) {
        console.error('‚ö†Ô∏è Erreur setActiveOrganization:', orgError);
        // Ne pas bloquer si √ßa √©choue, mais logger l'erreur
      }

      // √âTAPE 4: Synchroniser la facturation des si√®ges (NON-BLOQUANT)
      try {
        console.log(`üîÑ √âTAPE 4: Synchronisation facturation pour organisation ${organizationId}`);
        console.log(`üë§ Utilisateur invit√©: ${session.user.email}`);
        
        const { mongoDb } = await import("@/src/lib/mongodb");
        const { ObjectId } = await import("mongodb");

        // V√©rifier que l'organisation a un abonnement avant de synchroniser
        const subscription = await mongoDb.collection("subscription").findOne({
          referenceId: organizationId
        });

        if (!subscription || !subscription.stripeSubscriptionId) {
          console.log(`‚ÑπÔ∏è Organisation ${organizationId} en plan Free, pas de facturation √† synchroniser`);
        } else {
          console.log(`üìã Organisation ${organizationId} a un abonnement Pro, synchronisation...`);
          
          const { auth: authInstance } = await import("@/src/lib/auth");
          const adapter = authInstance.options.database;
          
          await seatSyncService.syncSeatsAfterInvitationAccepted(
            organizationId,
            adapter
          );

          console.log(`‚úÖ Facturation synchronis√©e avec succ√®s`);
        }
      } catch (billingError) {
        // NE PAS bloquer l'acceptation si la facturation √©choue
        console.error("‚ö†Ô∏è Erreur synchronisation facturation (non-bloquant):", billingError);
        console.warn("‚ö†Ô∏è Le membre a √©t√© ajout√© mais la facturation n'a pas √©t√© synchronis√©e");
        // Continuer sans erreur
      }

      // √âTAPE 5: Envoyer les emails de notification (NON-BLOQUANT)
      try {
        console.log('üîÑ √âTAPE 5: Envoi des emails de notification...');
        
        console.log('üìã R√©cup√©ration des informations...');
        console.log('Organization ID:', organizationId);
        console.log('Inviter ID:', result.invitation.inviterId);
        console.log('Member User ID:', result.member.userId);
        
        // R√©cup√©rer les informations compl√®tes (convertir les IDs en ObjectId)
        const [organization, inviter, memberUser] = await Promise.all([
          mongoDb.collection("organization").findOne({ _id: new ObjectId(organizationId) }),
          mongoDb.collection("user").findOne({ _id: new ObjectId(result.invitation.inviterId) }),
          mongoDb.collection("user").findOne({ _id: new ObjectId(result.member.userId) })
        ]);

        console.log('üìä Donn√©es r√©cup√©r√©es:');
        console.log('- Organization:', organization?.name);
        console.log('- Inviter:', inviter?.email);
        console.log('- Member:', memberUser?.email);

        // Trouver l'owner de l'organisation
        const ownerMember = await mongoDb.collection("member").findOne({
          organizationId: new ObjectId(organizationId),
          role: "owner"
        });
        
        const owner = ownerMember ? await mongoDb.collection("user").findOne({
          _id: new ObjectId(ownerMember.userId)
        }) : null;

        console.log('- Owner:', owner?.email);

        const emailData = {
          organization: { name: organization?.name || 'Organisation' },
          member: {
            user: {
              name: memberUser?.name,
              email: memberUser?.email
            },
            role: result.member.role
          }
        };

        // Envoyer l'email √† l'owner (si diff√©rent de l'inviter)
        if (owner && owner.email !== inviter?.email) {
          console.log(`üìß Envoi email √† l'owner: ${owner.email}`);
          await sendEmail({
            to: owner.email,
            subject: `${memberUser?.name || memberUser?.email} a rejoint ${organization?.name}`,
            html: emailTemplates.memberJoinedNotificationOwner(emailData)
          });
          console.log(`‚úÖ Email envoy√© √† l'owner: ${owner.email}`);
        } else {
          console.log(`‚ÑπÔ∏è Pas d'email √† l'owner (owner = inviter ou owner non trouv√©)`);
        }

        // Envoyer l'email √† l'inviter
        if (inviter?.email) {
          console.log(`üìß Envoi email √† l'inviter: ${inviter.email}`);
          await sendEmail({
            to: inviter.email,
            subject: `${memberUser?.name || memberUser?.email} a accept√© votre invitation`,
            html: emailTemplates.memberJoinedNotificationInviter(emailData)
          });
          console.log(`‚úÖ Email envoy√© √† l'inviter: ${inviter.email}`);
        }

        // Envoyer l'email de confirmation au nouveau membre
        if (memberUser?.email) {
          console.log(`üìß Envoi email de confirmation au membre: ${memberUser.email}`);
          await sendEmail({
            to: memberUser.email,
            subject: `Bienvenue dans ${organization?.name}`,
            html: emailTemplates.memberJoinedConfirmation(emailData)
          });
          console.log(`‚úÖ Email de confirmation envoy√© au nouveau membre: ${memberUser.email}`);
        }

        console.log('‚úÖ √âTAPE 5 OK: Emails de notification envoy√©s');
      } catch (emailError) {
        // NE PAS bloquer si l'envoi d'email √©choue
        console.error('‚ö†Ô∏è Erreur envoi emails (non-bloquant):', emailError);
        console.error('Stack:', emailError.stack);
        // Continuer sans erreur
      }

      console.log('‚úÖ TOUTES LES √âTAPES TERMIN√âES AVEC SUCC√àS');
      return Response.json({ success: true, organizationId, member: result.member });
    } else if (action === "reject") {
      const result = await auth.api.rejectInvitation({
        headers: await headers(),
        body: { invitationId: id },
      });
      return Response.json(result);
    } else {
      return Response.json({ error: "Action non valide" }, { status: 400 });
    }
  } catch (error) {
    console.error("‚ùå Erreur lors de l'action sur l'invitation:", error);
    return Response.json(
      { error: "Erreur serveur", details: error.message },
      { status: 500 }
    );
  }
}
